<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="Resource-type" content="Document" />
    <link rel="stylesheet" type="text/css" href="fullpage.min.css" />
    <script type="text/javascript" src="fullpage.min.js"></script>
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <script type="text/javascript" src="bootstrap.min.js"></script>
</head>
<body>
  <div id="fullpage">
    <div class="section">
      <div class="container">
        <h1>Algoritmo de euclides</h1>
        <div ng-app="miAlgoritmo" ng-controller="miCtrl">
          <h2>Cálculo de M.C.D. con el algoritmo de Euclides</h2>
          <div>1er número: </div>
          <input id="n1" min="1" ng-model="n1" type="number"><br>
          <div>2do número: </div>
          <input id="n1" min="1" ng-model="n2" type="number"><br>
          <br>
          
          <div id="r" >Máximo común divisor (M.C.D.): {{(n1>0 && n2>0)?EuclidesMCD(n1,n2):""}}</div>
          <div id="r" >Mínimo común múltiplo (M.C.M.): {{(n1>0 && n2>0)?EuclidesMCM(n1,n2):""}}</div> 
        </div>
      </div>
    </div>
    <div class="section">
      <div class="container">
        <div class="slide" id="slide1" data-anchor="slide1">
          <h1>Algoritmo de dikjstra</h1>
          
        </div>
    
        <div class="slide" id="slide2" data-anchor="slide2">
          <h1>Ejemplo 1</h1>
          <canvas id="myCanvas" width="900" height="700"></canvas>
        </div>
    
        <div class="slide" id="slide3" data-anchor="slide3">
          <h1>Ejemplo 2</h1>
          <canvas id="myCanvas2" width="900" height="700"></canvas>
        </div>	
        <div class="slide" id="slide3" data-anchor="slide3">
          <h1>Ejemplo 3</h1>
          <canvas id="myCanvas3" width="900" height="700"></canvas>
        </div>
        <div class="slide" id="slide3" data-anchor="slide3">
          <h1>Ejemplo 4</h1>
          <canvas id="myCanvas4" width="900" height="700"></canvas>
        </div>
      </div>
    </div>

  </div>


</body>
</html>
<script>

var myFullpage = new fullpage('#fullpage', {
		sectionsColor: ['#f2f2f2', '#4BBFC3', '#7BAABE', 'whitesmoke', '#ccddff'],
    slidesNavigation: true,
	});
/* algoritmo de euclides */
function EuclidesMCD(a, b) {
  var iaux; //auxiliar
  a = Math.abs(a); //tomamos valor absoluto
  b = Math.abs(b);
  var i1 = Math.max(a, b); //i1 = el más grande
  var i2 = Math.min(a, b); //i2 = el más pequeño

  do {
    iaux = i2; //guardar divisor
    i2 = i1 % i2; //resto pasa a divisor
    i1 = iaux; //divisor pasa a dividendo
  } while (i2 !== 0);
  return i1; //ultimo resto no nulo
}

function EuclidesMCM( a,  b)
{
    return (a / EuclidesMCD(a, b)) * b;
}

let graph = {
	I: { A: 2, D: 1, C: 3, B: 2 },
	A: { I: 2, B: 5, E: 7, H: 8 },
	B: { A: 5, I: 2, E: 6, G: 1, C: 8 },
	C: { I: 3, B: 8, D: 6, G: 5, E: 3},
	D: { I: 1, C: 5, G: 3, J: 2 },
  E: { A: 7, B: 6, C: 3, G: 1, J: 3, H: 6},
  G: { B: 1, E: 1, C: 5, D: 3, J: 1, H: 2},
  H: { A: 8, E: 6, G: 2, J: 5, K: 2, F: 6},
  J: { H: 5, E: 3, G: 1, K: 1, F: 2, D: 2},
  K: { H: 2, J: 1, F: 3},
	F: { H: 6, K: 3, J: 2},
};

let shortestDistanceNode = (distances, visited) => {
    // create a default value for shortest
      let shortest = null;
      
        // for each node in the distances object
      for (let node in distances) {
          // if no node has been assigned to shortest yet
            // or if the current node's distance is smaller than the current shortest
          let currentIsShortest =
              shortest === null || distances[node] < distances[shortest];
              
            // and if the current node is in the unvisited set
          if (currentIsShortest && !visited.includes(node)) {
              // update shortest to be the current node
              shortest = node;
          }
      }
      return shortest;
  };

let findShortestPath = (graph, startNode, endNode) => {
 
  // track distances from the start node using a hash object
    let distances = {};
    distances[endNode] = "Infinity";
    distances = Object.assign(distances, graph[startNode]);
    // track paths using a hash object
    let parents = { endNode: null };
    for (let child in graph[startNode]) {
      parents[child] = startNode;
    }
 
   // collect visited nodes
   let visited = [];
   // find the nearest node
   let node = shortestDistanceNode(distances, visited);
 
    // for that node:
    while (node) {
       // find its distance from the start node & its child nodes
       let distance = distances[node];
       let children = graph[node]; 
 
       // for each of those child nodes:
       for (let child in children) {
 
          // make sure each child node is not the start node
          if (String(child) === String(startNode)) {
             continue;
          } else {
             // save the distance from start node to child node
             let newdistance = distance + children[child];
             // if there’s no recorded distance from the start node to the child node in the distances object
             // or if the recorded distance is shorter than the previously stored distance from the start node to the child node
             if (!distances[child] || distances[child] > newdistance) {
                // save the distance to the object
                distances[child] = newdistance;
                // record the path
                parents[child] = node;
            } 
         }
      } 
    // move the current node to the visited set
    visited.push(node);
   // move to the nearest neighbor node
   node = shortestDistanceNode(distances, visited);
   }
 
   // using the stored paths from start node to end node
   // record the shortest path
   let shortestPath = [endNode];
   let parent = parents[endNode];
   while (parent) {
      shortestPath.push(parent);
      parent = parents[parent];
   }
   shortestPath.reverse();
 
   //this is the shortest path
// return the shortest path & the end node’s distance from the start node

  const results = {
    distance: distances[endNode],
    path: shortestPath
  };

  return results;
};

console.log(findShortestPath(graph, "A", "K"));


/* dibujo */
var canvas = document.getElementById('myCanvas');
var context = canvas.getContext('2d');

function Circle(I) {
   I.radius = 20;

   I.draw = function() {
       context.beginPath();
       context.arc(I.x, I.y, I.radius, 0, 2 * Math.PI, false);
       context.fillStyle = 'white';
       context.fill();
       context.lineWidth = 2;
       context.strokeStyle = '#003300';
       context.stroke();
       context.font = '15pt Calibri';
       context.fillStyle = 'black';
       context.textAlign = 'center';
       context.fillText(I.label, I.x, I.y);
   }

   return I;
}

var circles = [];

circles.push(Circle({
    x: 100,
    y: 100,
    label: "I"
}));
circles.push(Circle({
    x: 250,
    y: 200,
    label: "A"
}));
circles.push(Circle({
    x: 400,
    y: 300,
    label: "B"
}));
circles.push(Circle({
    x: 550,
    y: 400,
    label: "C"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "D"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "E"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "G"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "H"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "I"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "J"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "K"
}));
circles.push(Circle({
    x: 700,
    y: 100,
    label: "F"
}));
// Do above for all your circles

function drawArrow(from, to) {
    var radians = Math.PI / 180;
    var headlen = 10;
    var angle = Math.atan(Math.abs(from.y - to.y) / Math.abs(from.x - to.x));
    var rise = from.radius * Math.sin(angle);
    var run = to.radius * Math.cos(angle);
    context.beginPath();
    context.strokeText('2',to.x-75, to.y-30);
    
    if (from.x < to.x) {
        from.x += run;
        to.x -= run;
    } else {
        from.x -= run;
        to.x += run;
    }
    if (from.y < to.y) {
        from.y += rise;
        to.y -= rise;
    } else {
        from.y -= rise;
        to.y += rise;
    }
    context.moveTo(from.x, from.y);
    context.lineTo(to.x, to.y);
    console.log("texto a poner", from.x, from.y, to.x, to.y)
    context.stroke();
    // context.lineTo(to.x - headlen * Math.cos(angle - Math.PI / 6), to.y - headlen * Math.sin(angle - Math.PI / 6));
    // context.moveTo(to.x, to.y);
    // context.lineTo(to.x - headlen * Math.cos(angle + Math.PI / 6), to.y - headlen * Math.sin(angle + Math.PI / 6));
    // context.stroke();    
}

let lastCircle
circles.forEach(function(circle, index) {
  console.log(index);
  if(index != 0){
    drawArrow(lastCircle, circle);
  }
  lastCircle = circle;
    circle.draw();
});


</script>

